
<p align="center">
    <img src="https://user-images.githubusercontent.com/6702424/79351107-900eb300-7f38-11ea-8272-91ff725d29f3.png">
</p>
<p align="center">
    <i>ðŸ¦• Support Deno and release on NPM with a single codebase. ðŸ¦•</i>
</p>
<br>

This tool takes as input a TypeScript codebase that was meant to target node and/or the web and spits out a modified version of the source files that are ready to be deployed as a Deno module.  
  
**Denoify does for deno what browserify does for the browser.**

# Motivation

Although it is quite easy to port a module to deno it is a chore to maintain two codebases.

# Real world example

Modules that have been made cross-compatible using denoify:

- [evt](https://evt.land)
- [run-exclusive](https://github.com/garronej/run-exclusive)

# Will it work with my module ?

- Does your user need to have ``@types/node`` installed to use your package ? 
  If yes then, unfortunately, your module is not denoifiable as it is. 
  Even if you are allowed to use (some, not all) node builtins
  such as ``fs``, ``path`` or ``event`` you will need to remove all Node reference from your exposed API before you can use Denoify. 
  You can't for example expose a class that extends ``EventEmitter`` or if you do you will have to export a type definition
  for ``EventEmitter``.
- You will need to provide a polyfill for each of your dependency denoify does not has a polyfill for. 
  You can check this list [here](https://github.com/garronej/denoify/blob/master/knownPorts.jsonc). 
  Note that Denoify work recursively meaning that you can fork your dependencies repo and denoify them yourself.  
  However, depending on how deep your dependencies tree goes it might not be feasible.

# Roadmap to 1.0

The project is at an early stage. Current TODO list; 

- Using the typescript compiler API to parse source files instead of doing the change with RegExps. [ts-morph](https://github.com/dsherret/ts-morph) seems to be a good option here.
- Polyfills global node API that are not imported like Buffer and process. ( language parsing must land first )
- Allows require() ( synchronous dynamical loading of modules )
- Support for vanilla JavaScript projects ( currently only support TypeScript )

# Last release

This is the ``master`` branch that could be broken. Checkout [the last release](https://github.com/garronej/denoify/tree/v0.1.0)

# Requirements

This section is just to give an idea of what has to be done to enable denoify to work.  
Refer to the tutorial for step by step instructions.

- All the ``*.ts`` files must be contained in a single directory at the root of your project ( typically ``src`` or ``lib`` ).
- The ``tsconfig.json`` must use the ``"compilerOptions"`` -> ``"outDir"`` option.
- All strict TS checks must be enabled in ``tsconfig.json`` ( ``"noUnusedLocals"``, ``"noUnusedParameters"`` and ``"strict"`` )
- You must provide a deno port for each of yours dependencies that are not listed in [knownPorts.jsonc](https://github.com/garronej/denoify/blob/master/knownPorts.jsonc) and are not denoified. ( It is possible to fork your dependencies project and denoify it yourself ) 
- Your project must be hosted on GitHub and the files generated by ``denoify`` should be tracked ( ``./deno_dist`` and ``./mod.ts`` ).
- The ``"repository"`` entry in the ``package.json`` file must be completed. ( it is probably already the case, ``npm`` gives a warning if it is not anyway )
- Each time you publish a release on NPM (``> npm publish``)  you must also create a new release on GitHub with tag name ``vX.Y.Z`` corresponding to your package json.

# TUTORIAL

Check out [this repo](https://github.com/garronej/my_dummy_npm_and_deno_module) to see in practice how to setup your denoify with your repo.

